/**
 * 64. 最小路径和 (Minimum Path Sum)
 * 
 * 给定一个 `m x n` 的网格 `grid`，其中每个单元格包含一个非负整数。
 * 机器人从 **左上角** 出发，每次只能向 **右** 或者 **向下** 移动，直到到达 **右下角**。
 * 机器人需要找到一条路径，使得路径上的数字总和最小，并返回这个最小路径和。
 * 
 * **示例 1：**
 * 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
 * 输出：7
 * 解释：最小路径为 1 → 3 → 1 → 1 → 1，总和为 7。
 * 
 * **示例 2：**
 * 输入：grid = [[1,2,3],[4,5,6]]
 * 输出：12
 * 
 * **提示：**
 * 1. `m == grid.length`
 * 2. `n == grid[i].length`
 * 3. `1 <= m, n <= 200`
 * 4. `0 <= grid[i][j] <= 100`
 */

function minPathSum(grid: number[][]): number {
    let m = grid.length, n = grid[0].length; // 获取网格的行数 (m) 和列数 (n)
    
    // 遍历整个网格，并更新最优路径
    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (i == 0 && j == 0) {
                // 起点 (0,0) 无需更新，保持原值
                continue; 
            } else if (i == 0) {
                // 处理第一行: 只能从左侧单元格到达 (j-1, 左侧)
                grid[i][j] += grid[i][j - 1]; 
            } else if (j == 0) {
                // 处理第一列: 只能从上方单元格到达 (i-1, 上方)
                grid[i][j] += grid[i - 1][j]; 
            } else {
                // 其他情况: 取 **上方** 或 **左侧** 的最小路径和
                grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]);
            }
        }
    }
    
    // 返回右下角 (m-1, n-1) 的最小路径和
    return grid[m - 1][n - 1];
}
