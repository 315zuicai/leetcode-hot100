/**
 * 62. 不同路径 (Unique Paths)
 * 
 * 一个机器人位于 `m x n` 网格的左上角（起点 `grid[0][0]`）。
 * 机器人每次只能向**右**或者**向下**移动一步。机器人要到达网格的**右下角**（终点 `grid[m-1][n-1]`）。
 * 
 * 请计算机器人从起点到终点的**不同路径总数**。
 * 
 * **示例 1：**
 * 输入：m = 3, n = 7
 * 输出：28
 * 
 * **示例 2：**
 * 输入：m = 3, n = 2
 * 输出：3
 * 解释：
 * 机器人从左上角到右下角总共有 3 条路径：
 * 1. 向下 -> 向下 -> 向右
 * 2. 向下 -> 向右 -> 向下
 * 3. 向右 -> 向下 -> 向下
 * 
 * **示例 3：**
 * 输入：m = 7, n = 3
 * 输出：28
 * 
 * **示例 4：**
 * 输入：m = 3, n = 3
 * 输出：6
 * 
 * **提示：**
 * 1. `1 <= m, n <= 100`
 * 2. 题目数据保证答案小于等于 `2 * 10^9`
 */

// function uniquePaths(m: number, n: number): number {
//     let res = 1; // 结果变量，初始值设为1
//     for (let i = 1; i <= m - 1; i++) {
//         // 计算 C(m+n-2, m-1) = (m+n-2)! / [(m-1)! * (n-1)!]
//         res = res * (n - 1 + i) / i;
//     }
//     return Math.round(res); // 由于浮点运算可能产生误差，四舍五入确保正确结果
// }


function uniquePaths(m: number, n: number): number {
    // 创建二维数组 dp，大小为 m * n，并初始化所有值为 1
    let dp: number[][] = Array(m).fill(0).map(() => Array(n).fill(1));

    // 遍历整个网格，从 (1,1) 开始计算不同路径数
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            // 状态转移方程：当前格子的路径数 = 上方的路径数 + 左侧的路径数
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    // 返回终点 (m-1, n-1) 位置的路径数
    return dp[m - 1][n - 1];
}
